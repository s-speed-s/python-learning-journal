from collections import deque

class Graph:
    def __init__(self):
        self.adj_list = {}

    def add_vertex(self, name):
        if name not in self.adj_list:
            self.adj_list[name] = []

    def add_edge(self, start, end):
        if start in self.adj_list and end in self.adj_list:
            self.adj_list[start].append(end)
        else:
            print(f"Error: One or both landmarks '{start}' or '{end}' do not exist.")

    def display(self):
        print("Graph:")
        for vertex, edges in self.adj_list.items():
            print(f"{vertex} -> {edges}")

    def bfs(self, start):
        print("\nBFS Traversal:")
        visited = set()
        queue = deque([start])

        while queue:
            current = queue.popleft()
            if current not in visited:
                print(current)
                visited.add(current)
                for neighbor in self.adj_list[current]:
                    if neighbor not in visited:
                        queue.append(neighbor)

    def dfs(self, start):
        print("\nDFS Traversal:")
        visited = set()
        stack = [start]

        while stack:
            current = stack.pop()
            if current not in visited:
                print(current)
                visited.add(current)
                for neighbor in reversed(self.adj_list[current]):
                    if neighbor not in visited:
                        stack.append(neighbor)

    def bfs_shortest_path(self, start, goal):
        print(f"\nShortest Path from '{start}' to '{goal}':")
        if start not in self.adj_list or goal not in self.adj_list:
            print("One or both landmarks do not exist.")
            return

        visited = set()
        queue = deque([(start, [start])])

        while queue:
            current, path = queue.popleft()
            if current == goal:
                print(" -> ".join(path))
                return
            if current not in visited:
                visited.add(current)
                for neighbor in self.adj_list[current]:
                    if neighbor not in visited:
                        queue.append((neighbor, path + [neighbor]))

        print("No path found.")

#city information generated by chat gpt
def build_sample_city_graph():
    city = Graph()

    landmarks = [
        "Museum", "Library", "City Hall", "Zoo", "Aquarium",
        "Train Station", "Stadium", "University", "Airport", "Park"
    ]

    for landmark in landmarks:
        city.add_vertex(landmark)

    roads = [
        ("Museum", "Library"),
        ("Library", "City Hall"),
        ("City Hall", "Zoo"),
        ("Zoo", "Aquarium"),
        ("Aquarium", "Train Station"),
        ("Train Station", "Stadium"),
        ("Stadium", "University"),
        ("University", "Airport"),
        ("Airport", "Park"),
        ("Park", "Museum"),
        ("Library", "Zoo"),
        ("Zoo", "Train Station"),
        ("City Hall", "University"),
        ("University", "Museum"),
        ("Stadium", "Park")
    ]

    for start, end in roads:
        city.add_edge(start, end)

    return city
    
city_graph = build_sample_city_graph()
city_graph.display()

start_point = "Museum"
city_graph.bfs(start_point)
city_graph.dfs(start_point)

city_graph.bfs_shortest_path("Museum", "Airport")
